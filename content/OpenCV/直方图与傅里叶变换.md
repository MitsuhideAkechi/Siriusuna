# 直方图绘制
把图像拆解为像素点，统计里面的值出现次数

可以直观地了解该图像的对比度，亮度，强度分布等。

![](IMG-20251210185603993.png)
横坐标为像素数值，纵坐标为频数

函数:
![](IMG-20251210185604017.png)
![](IMG-20251210185604139.png)
```python
hist = cv2.calcHist([img], [0], None, [256], [0, 256])
```
绘制：
![](IMG-20251210185604162.png)
![](IMG-20251210185604187.png)

创建 mask 掩码：
```python
mask = np.zeros(img, shape[:2], np.uint8)
mask[100:300, 100:400] = 255
```
![](IMG-20251210185604312.png)
要保留的位置置为 `8'b1111_1111`，其余为 0

```python
hist_mask = cv2.calcHist([img], [0], mask, [256], [0, 256])
```

# 直方图均衡化
提升色彩和亮度
![](IMG-20251210185604449.png)
![](IMG-20251210185604477.png)
![](IMG-20251210185604506.png)
映射关系：$灰度值 = \lceil 累积概率 \times 范围 \rceil$

代码：
```python
equ = cv2.equalizeHist(img)
```

![](IMG-20251210185604628.png)

## 自适应均衡化
防止一些细节被“平均”，导致细节丢失
![](IMG-20251210185604656.png)
因此要分成格子，分别均衡化 (并且有一些线性插值处理，防止块间边界)，但是这样容易受到噪音影响，要权衡考虑

代码：
```python
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
res = clahe.apply(img)
```
![](IMG-20251210185604689.png)

# 傅里叶变换
## 频率
- 高频：变化剧烈的灰度分量，例如边界
- 低频：变化缓慢的灰度分析，例如海面
## 滤波
- 低通滤波器：只保留低频，会使得图像模糊
- 高通滤波器：只保留高频，会增强图像细节

## 频域转换
- 函数：`dft()`，`idft()`，分别为傅里叶变换和逆变换，输入前先转换成 `np.float32` 格式。
- 得到的结果，0 频率在左上角，通常用 `shift` 变换转到中心，反之用 `ishift` 转移回去。
- `cv2.dft()` 返回结果为双通道（虚实部），通常要转化为图像形式显示
![](IMG-20251210185604801.png)
距离中心点越近，频率越低

### 滤波操作
滤波后逆变换展示图片
- 低通滤波
![](IMG-20251210185604826.png)

结果：
![](IMG-20251210185604852.png)

- 高通滤波
![](IMG-20251210185604975.png)

结果：
![](IMG-20251210185605124.png)
