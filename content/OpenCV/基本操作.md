# 基本操作

# 图像
数据读取：
```python
import cv2 # opencv 的读取顺序是BGR
import numpy as np

img = cv2.imread("cat.jpg") # 结果为numpy的ndarray
```

图像展示：
```python
cv2.imshow("image", img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```
![](IMG-20251210185603535.png)
靠 `numpy` 的栈结构展示所有图片

图像保存：
```python
cv2.imwrite("my_cat.png", img)
```

图像属性：
```python
img.shape # (H, W, C) C 为通道数
img.size  # 像素点个数(H * W)
```

大小调整
```python
img1 = cv2.resize(img, (W, H))
img2 = cv2.resize(img, (0, 0), fx= , fy= ) # 宽高缩放倍数
```
![](IMG-20251210185603780.png)
![](IMG-20251210185603803.png)

***`cv.imread()` 参数：***
- `cv2.IMREAD_COLOR`
- `cv2.IMREAD_GRAYSCALE` (灰度图)
![](IMG-20251210185603829.png)

# 视频
打开视频
```python
vc = cv2.VideoCapture("test.mp4") # 可以捕获摄像头，也可以输入路径读取视频
if vc.isOpened():
	open, frame = vc.read() # 按帧读取，返回成功与否、本帧图像
else:
	open = False
while open:
	ret, frame = vc.read()
	if frame is None:
		break
	if ret == True:
		gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 每一帧转化为灰度图
		cv2.imshow("result", gray)
		if cv2.waitKey(100) & 0xFF == 27: # 按 esc 退出
			break
vc.release()
cv2.destoryAllWindows()
```

# ROI 区域（截取部分图像数据）
```python
img = cv2.imread("mycat.png")
cat = img[0:200, 0:200]
cv2.imshow("cat", cat)
```
读入数据本身是个 `ndarray`，可以和数组一样操纵、切片

# 颜色通道提取与合并
```python
b, g, r = cv2.split(img)
# or
b, g, r = img[:, :, 0], img[:, :, 1], img[:, :, 2]

img = cv2.merge(b, g, r)
```
![](IMG-20251210185603852.png)
```python
cur_img = img.copy()
cur_img[:, :, 1] = 0
cur_img[:, :, 2] = 0
# 仅保留 B ，蓝色图
```

# 边界填充
```python
top_size, bottom_size, left_size, right_size = (50, 50, 50, 50)
replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REPLICATE)
reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT)
reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT_101)
wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_WRAP)
constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_CONSTANT, value=0)
```
仅最后的 type 不同，区别如下：
![](IMG-20251210185603968.png)

# 数值计算
```python
img_cat = cv2.imread("cat.jpg")
img_dog = cv2.imread("dog.jpg")

img_cat = img_cat + 10 # 在每个像素点上都 + 10

img1 = img_cat + img_dog # 必须尺寸一样，使得对应像素相加，自动模256 

img2 = cv2.add(img_cat, img_dog) # 如果相加大于255，取255
```

# 图像融合
```python
res = cv2.addWeighted(img_cat, 0.4, img_dog, 0.6, 0) # 加权，末了为偏置项
```
$R = \alpha x_1 + \beta x_2 + b$

