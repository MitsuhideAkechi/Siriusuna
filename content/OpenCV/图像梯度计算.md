# Sobel 算子
提取轮廓
![](IMG-20251210185600830.png)
右减左，下减上
![](IMG-20251210185600870.png)
![](IMG-20251210185601009.png)
-  `ddepth` 一般指定-1，与输入一样（在 OpenCV 里，**“图像深度（depth）”** 指的其实就是 **每个像素的数据类型（data type）**，比如是 `8位整数`、`16位整数` 还是 `32/64位浮点数` —— 而不是图像的“位深度”或“通道数”。）
- `dx`, `dy` 为 0 或 1
```python
sobelx = cv2.Sobel(img, cv2.CV64F, 1, 0, ksize=3)
```
`cv2.CV64F` 提升位数，表示负数，用于后面取绝对值（白到黑是正，黑到白就是负了）
```python
sobelx = cv2.convertScaleAbs(sobelx)
```
取绝对值
![](IMG-20251210185601033.png)
![](IMG-20251210185601058.png)
总的梯度为两个方向上的求和
```python
sobelxy = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0)
```
![](IMG-20251210185601084.png)
（不建议 `dx` `dy` 同时设为 1 之后同时计算）

例子：
![](IMG-20251210185601206.png)

# Scharr 算子
![](IMG-20251210185601233.png)
数值比 Sobel 算子大，对结果差异更大更敏感，对原图像描绘更细致  
是 Sobel 算子的精度优化版本，大小固定为 3
# Laplacian 算子
![](IMG-20251210185601256.png)
二阶导，对变化更敏感，但是不足之处在于容易受到噪音点的影响
（中心与周围比较，无 `dx`，`dy`）

例子：
![](IMG-20251210185601371.png)
![](IMG-20251210185601511.png)
